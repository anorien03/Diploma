% !TeX spellcheck = ru_RU
\chapter{Технологический раздел}

\section{Выбор языка программирования} 
В соответствии с требованиями к реализуемому программному обеспечению, в качестве языка программирования был выбран язык С, так как поддерживает реализацию всех необходимых системных вызовов.



\section{Реализация thread pool и poll} 
В листинге \ref{label} представлена реализация функции создания пулла потоков.

\begin{lstlisting}[caption=Функции создания пулла потоков, label={label}]
server_t *new_http_server(char host[HOST_SIZE], int port, int thread_num)
{
	server_t *server = calloc(1, sizeof(server_t));
	if (server == NULL)
		return NULL;
	strcpy(server->host, host);
	server->port = port;

	server->cl_num = sysconf(_SC_OPEN_MAX);
	if (server->cl_num < 0) {
		LOG_ERROR("Failed to alloc clients fds");
		free(server);
		return NULL;
	}

	server->clients = malloc(sizeof(struct pollfd) * server->cl_num);
	if (server->clients == NULL) {
		LOG_ERROR("Failed to alloc clients fds");
		free(server);
		return NULL;
	}
	for (ssize_t i = 0; i < server->cl_num; i++) {
		server->clients[i].fd = -1;
	}

	server->pool = tpool_create(thread_num);
	if (server->pool == NULL)
	{
		LOG_ERROR("Failed to create pool");
		free(server->clients);
		free(server);
		return NULL;
	}

	server->wd = calloc(PATH_NUM, sizeof(char));
	if (server->wd == NULL)
	{
		LOG_ERROR("Failed to alloc wd");
		tpool_destroy(server->pool);
		free(server->clients);
		free(server);
		return NULL;
	}

	if (getcwd(server->wd, PATH_NUM) == NULL)
	{
		LOG_ERROR("Failed to get wd");
		free(server->wd);
		tpool_destroy(server->pool);
		free(server->clients);
		free(server);
		return NULL;
	}

	LOG_INFO("Work dir: %s", server->wd);
	LOG_INFO("Server created");

	return server;
}

\end{lstlisting}



В листинге \ref{label1} представлена реализация сокета poll.

\begin{lstlisting}[caption=Функции применения сокета poll, label={label1}]
int wait_client(server_t *server)
{
	server->clients[0].fd = server->listen_sock;
	server->clients[0].events = POLLIN;
	int numfds = 0, maxcl = 0;
	int first = 0;

	while (1)
	{
		numfds = poll(server->clients, maxcl + 1, 5000);

		if (numfds < 0)
		{
			LOG_ERROR("poll error");
			continue;
		}

		if (server->clients[0].revents & POLLIN)
		{
			int client_sock = accept(server->listen_sock, NULL, NULL);
			if (client_sock < 0)
			{
				continue;
			}

			long i = 0;
			for (i = 1; i < server->cl_num; ++i)
			{
				if (server->clients[i].fd < 0)
				{
					server->clients[i].fd = client_sock;
					server->clients[i].events = POLLIN;
					break;
				}
			}
			if (i == server->cl_num) {
				LOG_ERROR("too many connections");
				continue;
			}

			if (i > maxcl)
			{
				maxcl = i;
				LOG_INFO("Max clients: %d", maxcl);
			}
			if (--numfds <= 0)
			{
				continue;
			}
		}
		for (int i = 1; i <= maxcl; ++i)
		{
			if (server->clients[i].fd >= 0 && server->clients[i].revents & (POLLIN | POLLERR))
			{
				worker_sock_t worker_sock;
				worker_sock.clientfd = &server->clients[i].fd;
				worker_sock.wd = server->wd;

				tpool_add_work(server->pool, worker, &worker_sock);

				if (--numfds < 0)
				{
					break;
				}
			}
		}
		tpool_wait(server->pool);

	}
}

\end{lstlisting}



\section{Демонстрация работы программы}
Рисунок \ref{img:screen.png} демонстрирует работу разработанного программного обеспечения. Запуск сервера производится из командной строки командой ./server из рабочей директории, запрос на сервер отправляется из браузера.

\img{0.30}{screen.png}{Демонстрация работы статического сервера}